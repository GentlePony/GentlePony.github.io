{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2020/09/08/MVRX%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/",
            "url": "http://example.com/2020/09/08/MVRX%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90/",
            "title": "",
            "date_published": "2020-09-08T15:40:42.324Z",
            "content_html": "<h2 id=\"app状态管理流程的分析\"><a class=\"markdownIt-Anchor\" href=\"#app状态管理流程的分析\">#</a> APP 状态管理流程的分析</h2>\n<h4 id=\"一-前言\"><a class=\"markdownIt-Anchor\" href=\"#一-前言\">#</a> 一、前言</h4>\n<p>​\t\t当前采用的是 MVRX 框架，而在这个框架中，个人认为最重要的就是 <code>BaseMvRxViewModel</code>  这个类，我们所有相关的修改数据、获取数据、订阅数据变化都是由这个类实现的，所以接下来主要就是分析这个类的工作流程。</p>\n<h4 id=\"二-分析basemvrxviewmodel\"><a class=\"markdownIt-Anchor\" href=\"#二-分析basemvrxviewmodel\">#</a> 二、分析 <code>BaseMvRxViewModel</code></h4>\n<p>1、初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract class BaseMvRxViewModel&lt;S : MvRxState&gt;(</span><br><span class=\"line\">    initialState: S,</span><br><span class=\"line\">    debugMode: Boolean &#x3D; false,</span><br><span class=\"line\">    private val stateStore: MvRxStateStore&lt;S&gt; &#x3D; RealMvRxStateStore(initialState)</span><br><span class=\"line\">) </span><br></pre></td></tr></table></figure>\n<p>​\t\t一般情况下我们继承 <code> BaseMvRxViewModel</code>  会在其主构造函数中传入一个实现 <code> MvRxState</code>  接口的 <code> Data Class</code> ，但与此同时它也会自己新建一个实现 <code> MvRxStateStore</code>  的对象，关于这个对象后面再讲（这个对象承载了上面所说的修改数据、获取数据、订阅数据变化等操作）接下来让我们看看 <code> BaseMvRxViewModel</code>  在它的初始化代码块儿做的一些事情：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Completable。他就像是一个返回为void的方法。他会成功完成，或者抛出一个异常。这就好比是一个响应式的Runnable。Completable包含了一组可以运行的代码，要么成功要么失败。</span></span><br><span class=\"line\">    Completable.fromCallable &#123;</span><br><span class=\"line\">        initialState::<span class=\"keyword\">class</span>.primaryConstructor?.parameters?.forEach &#123; it.annotations &#125;</span><br><span class=\"line\">        initialState::<span class=\"keyword\">class</span>.declaredMemberProperties.asSequence()</span><br><span class=\"line\">                .filter &#123; it.isAccessible &#125;</span><br><span class=\"line\">                .forEach &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Suppress(<span class=\"meta-string\">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class=\"line\">                    (it <span class=\"keyword\">as</span>? KProperty1&lt;S, Any?&gt;)?.<span class=\"keyword\">get</span>(initialState)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">    &#125;.subscribeOn(Schedulers.computation()).subscribe()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.debugMode) &#123;</span><br><span class=\"line\">        mutableStateChecker = MutableStateChecker(initialState)</span><br><span class=\"line\"></span><br><span class=\"line\">        Completable.fromCallable &#123; validateState(initialState) &#125;</span><br><span class=\"line\">            .subscribeOn(Schedulers.computation()).subscribe()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t在初始化代码块儿中，它使用 <code>RxJava</code>  的 <code>Completable</code>  对象的 fromCallable 方法异步的遍历了传入进的实现 <code> MvRxState</code>  接口的类的构造方法中的所有传入属性，同时也遍历了所有的非私有的成员属性。这么做的目的其原因是，第一次反射获取这些东西的开销是很大，在初始化代码块中进行一遍反射的获取后之后的在订阅中获取对应属性。</p>\n<p>二、数据修改、获取及订阅</p>\n<p>​\t应用中我们使用 viewModel 提供的一个 dsl 进行数据的修改，其实现如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">setState</span><span class=\"params\">(reducer: <span class=\"type\">S</span>.() -&gt; <span class=\"type\">S</span>)</span></span> &#123;</span><br><span class=\"line\">   stateStore.<span class=\"keyword\">set</span>(reducer)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t很简单，数据的修改最后调用了 <code> MvRxStateStore</code>  的 set 方法。接下来看获取数据的 dsl 的实现</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">withState</span><span class=\"params\">(block: (<span class=\"type\">state</span>: <span class=\"type\">S</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    stateStore.<span class=\"keyword\">get</span>(block)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t\t同样，是调用了 <code> MvRxStateStore</code>  的 get 方法，那么订阅数据的变化，观看几个订阅数据变化的方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">subscribe</span><span class=\"params\">(subscriber: (<span class=\"type\">S</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> =</span><br><span class=\"line\">    stateStore.observable.subscribeLifecycle(<span class=\"literal\">null</span>, <span class=\"literal\">false</span>, subscriber)</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;A&gt;</span> <span class=\"title\">selectSubscribe</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        prop1: <span class=\"type\">KProperty1</span>&lt;<span class=\"type\">S</span>, A&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        subscriber: (<span class=\"type\">A</span>) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span> = selectSubscribeInternal(<span class=\"literal\">null</span>, prop1, <span class=\"literal\">false</span>, subscriber)</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;A&gt;</span> <span class=\"title\">selectSubscribeInternal</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        owner: <span class=\"type\">LifecycleOwner</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        prop1: <span class=\"type\">KProperty1</span>&lt;<span class=\"type\">S</span>, A&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        uniqueOnly: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        subscriber: (<span class=\"type\">A</span>) -&gt; <span class=\"type\">Unit</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span> = stateStore.observable</span><br><span class=\"line\">        .map &#123; MvRxTuple1(prop1.<span class=\"keyword\">get</span>(it)) &#125;</span><br><span class=\"line\">        .distinctUntilChanged()</span><br><span class=\"line\">        .subscribeLifecycle(owner, uniqueOnly) &#123; (a) -&gt; subscriber(a) &#125;</span><br></pre></td></tr></table></figure>\n<p>​\t可以看到所有对数据更新订阅操作，实际上都是对 <code> MvRxStateStore</code>  返回的 <code> Observable</code>  的订阅。唯一的实质性的代码就只有初始化时，初始化反射的相关操作了。</p>\n<h4 id=\"三-realmvrxstatestore分析\"><a class=\"markdownIt-Anchor\" href=\"#三-realmvrxstatestore分析\">#</a> 三、 <code> RealMvRxStateStore</code>  分析</h4>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MvRxStateStore</span>&lt;<span class=\"type\">S : Any</span>&gt; : <span class=\"type\">Disposable &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> state: S</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(block: (<span class=\"type\">S</span>) -&gt; <span class=\"type\">Unit</span>)</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">set</span><span class=\"params\">(stateReducer: <span class=\"type\">S</span>.() -&gt; <span class=\"type\">S</span>)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> observable: Observable&lt;S&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t上面讲到， <code>BaseMvRxViewModel</code>  所有对数据的操作都是通过对 <code>MvRxStateStore</code>  操作来完成的，而 <code> RealMvRxStateStore</code>  时这个接口的唯一实现类，所以我们接下来开始分析 <code> RealMvRxStateStore</code> ：</p>\n<p>​\t首先我们先看看它的主构造函数</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealMvRxStateStore</span>&lt;<span class=\"type\">S : Any</span>&gt;</span>(initialState: S) : MvRxStateStore&lt;S&gt; </span><br></pre></td></tr></table></figure>\n<p>​\t\t看成员变量前，首先要先讲讲 Rxjava 中 <code>SubJect</code>  这个是用于干什么的，平常我们使用 Rxjava 用的最多可能会是一下几种： <code>Observable</code> 、 <code> Flowable</code>  这两种接口或抽象类的子集。但这两种实际上都只是返回一个被观察者的对象，并不能返回一个发射者的对象，简单的来讲使用 <code>Observable</code> 、 <code> Flowable</code>  我们只能在创建时显式的发射东西，然后在订阅时它会将其发射出来，一般情况下这是足够使用，因为通过这种方式去发射和观察，我们基本上不用关心它的生命周期，因为我们总会把它声明成一个局部变量。然而一些情况下这显然是不够用的，例如现在这种情况：我们希望数据变化时，能够引发我们在 <code> onCreate</code>  中的订阅，固然我们可以在数据变化时调用 <code>Observable</code> 、 <code> Flowable</code>  的・ <code>create</code>  然后再调用订阅的代码块，但这样所造成的后果是如果数据刷新很频繁，会在短时间大量的创建对象然后销毁，同时也会引发线程的经典问题，竞态条件，因为这些短时间创建的 <code>Observable</code> 、 <code> Flowable</code>  的对象不是运行在同一个线程上，这可能会导致得到的结果与我们想要达成的效果事与愿违。而 <code>SubJect</code>  就是 Rxjava 为了解决这一个问题所提供的一个类型，它不仅是一个被观察者还是一个观察者也就是说，它可以通过可以通过 onNext、onComplete、onError 方法发射和终止发射数据，也可以观察数据。以下是官方解释：</p>\n<p>​\tSubject 在 ReactiveX 是作为 observer 和 observerable 的一个 bridge 或者 proxy。因为它是一个观察者，所以它可以订阅一个或多个可观察对象，同时因为他是一个可观测对象，所以它可以传递和释放它观测到的数据对象，并且能释放新的对象。</p>\n<p>​\t再看其几个重要的成员属性：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The subject is where state changes should be pushed to.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> subject: BehaviorSubject&lt;S&gt; = BehaviorSubject.createDefault(initialState)</span><br></pre></td></tr></table></figure>\n<p>​\t一个 <code> BehaviorSubject</code>  的对象，这个对象负责存储最新数据的更新，以及之后的数据更新的订阅。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">val</span> observable: Observable&lt;S&gt; = subject</span><br></pre></td></tr></table></figure>\n<p>​\t返回观察数据的 <code>Observable</code> , <code>BaseMvRxViewModel</code>  订阅数据变化的订阅的对象实际上就是这个返回。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A subject that is used to flush the setState and getState queue. The value emitted on the subject is</span></span><br><span class=\"line\"><span class=\"comment\"> * not used. It is only used as a signal to flush the queues.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> flushQueueSubject = BehaviorSubject.create&lt;<span class=\"built_in\">Unit</span>&gt;()</span><br></pre></td></tr></table></figure>\n<p>​\t一个用于出队 setState 和 withStae 操作代码块的 <code> BehaviorSubject</code> 。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> jobs = Jobs&lt;S&gt;()</span><br></pre></td></tr></table></figure>\n<p>​\t用于存储 setState 和 withState 操作代码块的类：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> getStateQueue = LinkedList&lt;(state: S) -&gt; <span class=\"built_in\">Unit</span>&gt;()</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> setStateQueue = LinkedList&lt;S.() -&gt; S&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Synchronized</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">enqueueGetStateBlock</span><span class=\"params\">(block: (<span class=\"type\">state</span>: <span class=\"type\">S</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    getStateQueue.add(block)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Synchronized</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">enqueueSetStateBlock</span><span class=\"params\">(block: <span class=\"type\">S</span>.() -&gt; <span class=\"type\">S</span>)</span></span> &#123;</span><br><span class=\"line\">    setStateQueue.add(block)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Synchronized</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">dequeueGetStateBlock</span><span class=\"params\">()</span></span>: ((state: S) -&gt; <span class=\"built_in\">Unit</span>)? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getStateQueue.isEmpty()) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getStateQueue.removeFirst()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Synchronized</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">dequeueAllSetStateBlocks</span><span class=\"params\">()</span></span>: List&lt;(S.() -&gt; S)&gt;? &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do not allocate empty queue for no-op flushes</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setStateQueue.isEmpty()) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> queue = setStateQueue</span><br><span class=\"line\">    setStateQueue = LinkedList()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t可以看出来 job 类提供了 setState 和 withState 的相关的出队和入队方法，但需要注意的是，setState 的出队方法会将队列中所有的 setState 代码块出队，而 withState 的出队方法只会出队第一个代码块，至于为什么只出队第一个这个后面讲。</p>\n<p>其初始化代码块：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    flushQueueSubject.observeOn(Schedulers.newThread())</span><br><span class=\"line\">        <span class=\"comment\">// We don&#x27;t want race conditions with setting the state on multiple background threads</span></span><br><span class=\"line\">        <span class=\"comment\">// simultaneously in which two state reducers get the same initial state to reduce.</span></span><br><span class=\"line\">        .subscribe(&#123; _ -&gt; flushQueues() &#125;, ::handleError)</span><br><span class=\"line\">        <span class=\"comment\">// Ensure that state updates don&#x27;t get processes after dispose.</span></span><br><span class=\"line\">        .registerDisposable()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t初始化代码块中，初始化了 flushQueueSubject 的订阅，执行了 <code> flushQueues()</code>  的方法，该方法实现如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">flushQueues</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    flushSetStateQueue()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> block = jobs.dequeueGetStateBlock() ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">    block(state)</span><br><span class=\"line\">    flushQueues()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">flushSetStateQueue</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> blocks = jobs.dequeueAllSetStateBlocks() ?: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">    blocks</span><br><span class=\"line\">            .fold(state) &#123; state, reducer -&gt; state.reducer() &#125;</span><br><span class=\"line\">            .run &#123; </span><br><span class=\"line\"><span class=\"number\">1</span>                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != state) </span><br><span class=\"line\">                subject.onNext(<span class=\"keyword\">this</span>) </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t这是一个递归函数，首先出队所有的 setState 的代码块，然后遍历整个队列，并执行和如果 setState 返回的值与之前不一样（这里注意 1 处的代码是使用的 = 做的是否相等的判断，这里就是前面为什么用 <code> DATA CLASS</code>  做实现 <code> MvRxState</code>  原因，因为 <code> DATA CLASS</code>  是会根据主构造函数的参数自动重写的 <code> equals()</code>  方法的，因为我们希望数据变化才引发会调用，而不是数据类的 <code> hashCode</code>  变化引发回调），则调用 subject 发送数据，引起我们数据变化的回调，然后获取第一个 withState 的代码然后执行，如果 withState 队列不空则会继续执行该方法，直至 setState 和 withStatee 代码块的队列。</p>\n<p>​\t然后再看成员函数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">set</span><span class=\"params\">(stateReducer: <span class=\"type\">S</span>.() -&gt; <span class=\"type\">S</span>)</span></span> &#123;</span><br><span class=\"line\">    jobs.enqueueSetStateBlock(stateReducer)</span><br><span class=\"line\">    flushQueueSubject.onNext(<span class=\"built_in\">Unit</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">get</span><span class=\"params\">(block: (<span class=\"type\">S</span>) -&gt; <span class=\"type\">Unit</span>)</span></span> &#123;</span><br><span class=\"line\">    jobs.enqueueGetStateBlock(block)</span><br><span class=\"line\">    flushQueueSubject.onNext(<span class=\"built_in\">Unit</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>`BaseMvRxViewModel`的` withState()`和` setState()`调用的都是这两个函数，这两个函数只做了两件事，1、将操作入队，2、发射一个Unit引发` flushQueueSubject`的订阅。\n</code></pre>\n<p>​\t至此整个 MvRx 的脉路，我们就清楚了，当我们调用 <code>BaseMvRxViewModel</code>  的 <code> setState</code>  或  <code> withState</code>  时，都是先将操作入队而后发送了一个 Unit 给 <code> flushQueueSubject</code>  引发其订阅，然后 <code> flushQueueSubject</code>  订阅中如果数据内容变化，才会再将新的 state 通过 <code> subject</code>  发送给我们的订阅。</p>\n<p>​\t所以之前项目中的错误写法其实并不完全是多线程的问题，因为至始至终都是只有一个线程运行 <code> setState</code>  和 <code> withState</code>  中的代码，而是代码执行顺序的问题。为什么这样说呢思考之前项目中的写法</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请求1的回调</span></span><br><span class=\"line\">withState&#123;state-&gt;</span><br><span class=\"line\">          <span class=\"comment\">//一些数据的计算，可能会耗费比较长的时间</span></span><br><span class=\"line\">         state.doSomeThing()</span><br><span class=\"line\">         setState&#123;</span><br><span class=\"line\">         copy(propety = state.propety)</span><br><span class=\"line\">         \t&#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//请求2的回调</span></span><br><span class=\"line\">setState&#123;</span><br><span class=\"line\">\tcopy(someThingNew)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t当同时开启两个网络请求时，且网络请求成功的先后接近时，假设请求 1 先回来，这时，会将请求 1 的 withState 的代码先入 withState 队，然后开始执行，在执行请求 1 的 withState 的代码块时但还没有执行到其中的 setState 的代码块时，请求 2 的成功回调回来了，这时他调用 setState 将自己的修改数据的代码块放入 setState 的代码块队列中后，请求 1 执行到 setState，开始组装自己的数据然后将其放入到 setState 的代码块中。显然这个时候放入到 setState 队列中的代码块顺序已经错误了。因为请求 1 处理数据时，请求 2 还没有回来，但数据的修改却放在了请求 1 的前面，这使得请求 1 在 withState 的中做的数据处理全部的已经过期了，而这个时候请求 1 的数据再去 setState 的，自然会丢失掉请求 2 的修改。解决这个问题其实很简单，只要将请求 1 的 withState 中的数据处理放入 setState 中即可 (因为 setState 中的 this 是最新的 State 的对象)，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;请求1</span><br><span class=\"line\">         &#x2F;&#x2F;一些数据的计算，可能会耗费比较长的时间</span><br><span class=\"line\">     setState&#123;</span><br><span class=\"line\">       this.doSomeThing()</span><br><span class=\"line\">       copy(propety &#x3D; state.propety)</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">        </span><br></pre></td></tr></table></figure>\n<p>流程图如下：</p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CDesktop%5C%E9%99%B6%E6%80%9D%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%5C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B.jpg\" alt=\"\"></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2020/09/04/kotlin%E5%8D%8F%E7%A8%8B/",
            "url": "http://example.com/2020/09/04/kotlin%E5%8D%8F%E7%A8%8B/",
            "title": "",
            "date_published": "2020-09-03T16:44:20.075Z",
            "content_html": "<h1 id=\"kotlin协程\"><a href=\"#kotlin协程\" class=\"headerlink\" title=\"kotlin协程\"></a>kotlin协程</h1><h3 id=\"一、协程的优势\"><a href=\"#一、协程的优势\" class=\"headerlink\" title=\"一、协程的优势\"></a>一、协程的优势</h3><p>​            1、<strong>很容易切换到子线程</strong>。我们可以用很多方法来让操作远离主线程，AsyncTask、Loaders、ExecutorServices……甚至有开发者用到了 RxJava。但协程可以让开发者只需要一行代码就完成这个工作，而且没有累人的回调处理。</p>\n<p>​            2、<strong>协程是挂起式的而不是阻塞式的</strong> 挂起函数挂起协程时，不会阻塞协程所在的线程，它会将自己先从线程中脱离出去，让线程去干其他的事情。挂起函数执行完成后会自动恢复协程，后面的代码才会继续执行。但是挂起函数只能在协程中或其他挂起函数中调用。</p>\n<p>​            3、<strong>编译器会检测调用</strong> 当一个挂起函数被调用时，编译器会检测该函数的调用环境是否是一个协程上下文的环境</p>\n<p>​            4、<strong>结构化并发</strong> 想象一种情况，我们进一个页面需要，连续请求几个接口，当其中一个网络请求出错时或者此时退出页面，我们希望关闭其他并行的网络请求。如果用Rx实现，则需要使用zip操作符进行合并请求，然后持有zip返回的对象，在destory的时销毁。然而协程只需要你取消持有的最顶层上下文，那么其所有的字上下文就都会取消。</p>\n<h4 id=\"二、协程的基本组成\"><a href=\"#二、协程的基本组成\" class=\"headerlink\" title=\"二、协程的基本组成\"></a>二、协程的基本组成</h4><p>​            一个协程基本由三个部分组成<code>CoroutineContext</code>（协程上下文）、<code> CoroutineStart </code>（协程启动模式）、<code>block代码块</code>(协程体即代码块)。</p>\n<p>​        <strong>1、CoroutineContext（协程上下文）</strong></p>\n<p>​            协程上下文是用来指定协程代码块在哪个线程中执行，<code>kotlin</code>提供了几个默认的协程上下文，分别是<code>Default</code>、<code>Main</code>、<code>IO</code>、<code>Unconfined</code> 、<code>EmptyCoroutineContext</code>、<code>自定义调度器</code>, 并针对<code>jvm</code>, <code>kotlin</code>提供了一个特有的<code>IO</code>调度器</p>\n<p>​            先说说<code>Default</code>、<code>IO</code>、<code>Main</code>、``Unconfined`这四个属于Dispatchers</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;start:<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">//It is backed by a shared pool of threads on JVM.</span></span><br><span class=\"line\">    launch(Dispatchers.Default) &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;default:<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//与default共享一个线程池，所以有些时候会是同一个线程</span></span><br><span class=\"line\">    launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;io:<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//切换到主线程即UI线程,看似是切换，实际上是讲代码快post到了主线</span></span><br><span class=\"line\">    launch(Dispatchers.Main) &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;main:<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//保持之前的线程不变，但如果之前的线程已经取消或者死亡，则会自己开启一个新的线程来执行</span></span><br><span class=\"line\">    launch(Dispatchers.Unconfined) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">300</span>)</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;unconfined:<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;执行&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plain\"><figcaption><span>D/taosi: start:DefaultDispatcher-worker-1</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12447-12516&#x2F;? D&#x2F;taosi: default:DefaultDispatcher-worker-3</span><br><span class=\"line\">12447-12516&#x2F;? D&#x2F;taosi: io:DefaultDispatcher-worker-3</span><br><span class=\"line\">12447-12514&#x2F;? D&#x2F;taosi: unconfined:DefaultDispatcher-worker-1</span><br><span class=\"line\">12447-12514&#x2F;? D&#x2F;taosi: 执行</span><br><span class=\"line\">12447-12447&#x2F;? D&#x2F;taosi: main:main</span><br></pre></td></tr></table></figure>\n\n<p>​        <code>EmptyCoroutineContext</code>:空的上下文，当存在有父协程时，使用该上下文启动一个子协程则会继承父协程的上下文，即在父协程的线程上执行代码。若不在父协程，则会在default的线程池中获取编号为一的线程。</p>\n<pre><code>     CoroutineScope(EmptyCoroutineContext).launch &#123;\n            Log.d(&quot;taosi&quot;, Thread.currentThread().name)\n            launch(EmptyCoroutineContext) &#123;\n                delay(300)\n                Log.d(&quot;taosi&quot;, Thread.currentThread().name)\n            &#125;\n            delay(10000)\n        &#125;</code></pre>\n<p>​    结果:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">16675</span>-<span class=\"number\">16714</span>/com.example.coroutinedemo D/taosi: DefaultDispatcher-worker-<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">16675</span>-<span class=\"number\">16714</span>/com.example.coroutinedemo D/taosi: DefaultDispatcher-worker-<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>​    当父协程的上下文不存在时（即父协程已经执行完它的任务），若子协程的上下文指定为<code>EmptyCoroutineContext</code>，那么子协程是不会继承父协程的上下文的</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(EmptyCoroutineContext).launch &#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>, Thread.currentThread().id.toString())</span><br><span class=\"line\">    <span class=\"keyword\">val</span> job = launch(EmptyCoroutineContext) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">2000</span>)</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, Thread.currentThread().id.toString())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">15</span> <span class=\"number\">00</span>:<span class=\"number\">32</span>:<span class=\"number\">27.152</span> <span class=\"number\">18788</span>-<span class=\"number\">18832</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">35633</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">15</span> <span class=\"number\">00</span>:<span class=\"number\">32</span>:<span class=\"number\">29.160</span> <span class=\"number\">18788</span>-<span class=\"number\">18833</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">35634</span></span><br></pre></td></tr></table></figure>\n\n<p>​    自定义的协程上下文：有些时候你不想使用他创建的线程池的协程时采用这种方式或者你想两端段代码在同一个线程执行 ，可以使用<code>kotlin</code>自带<code>newSingleThreadContext</code>方法或者使用<code>ExecutorService</code>的扩展方法<code>asCoroutineDispatcher</code>创建一个<code>Dispatcher</code>。但这样创建的线程需要手动的close，否则该线程就永远不会终止。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> context1 = newSingleThreadContext(<span class=\"string\">&quot;custom_Thread1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> context2 = Executors.newSingleThreadExecutor&#123;r-&gt;</span><br><span class=\"line\">    Thread(r,<span class=\"string\">&quot;custom_Thread2&quot;</span>)</span><br><span class=\"line\">&#125;.asCoroutineDispatcher()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">launch(context1) &#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;customThread1:<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">launch(context2) &#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;customThread2:<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">13562</span>-<span class=\"number\">13605</span>/com.example.coroutinedemo D/taosi: customThread1:custom_Thread1</span><br><span class=\"line\"><span class=\"number\">13562</span>-<span class=\"number\">13607</span>/com.example.coroutinedemo D/taosi: customThread2:custom_Thread2\t</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、 CoroutineStart（协程启动模式）</strong></p>\n<p>​        <code>*DEFAULT</code></p>\n<p>​            这个模式代表一旦调用launch会自动执行代码块的代码，不需要手动调用，在调用lauch的函数时的默认值就是这个，列如以上代码都是没有指定启动模式</p>\n<p>​        <code>LAZY</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;default模式代码块开始&quot;</span>)</span><br><span class=\"line\">    launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;startModel::default&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;lazy模式代码块开始&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> job = launch(Dispatchers.IO, CoroutineStart.LAZY) &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;startModel::lazy&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">    job.join()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight plain\"><figcaption><span>21:20:57.562 16327-16368/? D/taosi: default模式代码块开始</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2020-06-14 21:20:57.562 16327-16368&#x2F;? D&#x2F;taosi: lazy模式代码块开始</span><br><span class=\"line\">2020-06-14 21:20:57.562 16327-16370&#x2F;? D&#x2F;taosi: startModel::default</span><br><span class=\"line\">2020-06-14 21:20:58.568 16327-16370&#x2F;com.example.coroutinedemo D&#x2F;taosi: startModel::lazy\t\t</span><br></pre></td></tr></table></figure>\n\n<p><code>CoroutineStart.LAZY</code>启动模式对于<code>Job</code>一定要手动调用<code>join</code>或<code>start</code>等方法.对于<code>Differed</code>一定要手动调用<code>await()</code>，否者协程体不会执行。</p>\n<p>​        <code>ATOMIC</code>:（实验性质）</p>\n<p>​            这个模式我暂时还没用过</p>\n<p>​        <code>UNDISPATCHED</code>（实验性质的参数）</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">           Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;UNDISPATCHED模式开始::<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">           launch(context1,CoroutineStart.UNDISPATCHED) &#123;</span><br><span class=\"line\">               Log.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;startModel::UNDISPATCHED::1::<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">               delay(<span class=\"number\">300</span>)</span><br><span class=\"line\">               Log.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;startModel::UNDISPATCHED::2::<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">           job.join()</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">21</span>:<span class=\"number\">45</span>:<span class=\"number\">46.233</span> <span class=\"number\">25658</span>-<span class=\"number\">25790</span>/com.example.coroutinedemo D/taosi: UNDISPATCHED模式代码块开始::DefaultDispatcher-worker-<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">21</span>:<span class=\"number\">45</span>:<span class=\"number\">46.235</span> <span class=\"number\">25658</span>-<span class=\"number\">25790</span>/com.example.coroutinedemo D/taosi: startModel::UNDISPATCHED::<span class=\"number\">1</span>::DefaultDispatcher-worker-<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">21</span>:<span class=\"number\">45</span>:<span class=\"number\">46.540</span> <span class=\"number\">25658</span>-<span class=\"number\">25794</span>/com.example.coroutinedemo D/taosi: startModel::UNDISPATCHED::<span class=\"number\">2</span>::custom_Thread1</span><br></pre></td></tr></table></figure>\n\n<p>​             在于到第一个挂起函数之前，当前的协程体会在父协程上下文执行代码，第一个挂起函数之后，代码就会由当前协程指定的调度器执行。</p>\n<h4 id=\"三、协程的构建器\"><a href=\"#三、协程的构建器\" class=\"headerlink\" title=\"三、协程的构建器\"></a>三、协程的构建器</h4><p>​        <code>CoroutineScope.launch &#123;&#125;</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">            Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;GlobalScope::代码块开始::<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">            GlobalScope.launch(EmptyCoroutineContext) &#123;</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;GlobalScope::<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">23</span>:<span class=\"number\">02</span>:<span class=\"number\">21.289</span> <span class=\"number\">2741</span>-<span class=\"number\">2800</span>/? D/taosi: GlobalScope::代码块开始::DefaultDispatcher-worker-<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">23</span>:<span class=\"number\">02</span>:<span class=\"number\">21.290</span> <span class=\"number\">2741</span>-<span class=\"number\">2800</span>/? D/taosi: 父协程开始执行</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">23</span>:<span class=\"number\">02</span>:<span class=\"number\">21.290</span> <span class=\"number\">2741</span>-<span class=\"number\">2802</span>/? D/taosi: GlobalScope::DefaultDispatcher-worker-<span class=\"number\">3</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>​    <code>CoroutineScope.launch &#123;&#125;</code> 是最常用的 Coroutine builders，不阻塞当前线程，在后台创建一个新协程，也可以指定协程调度器。GlobalScope.launc()也就是这种方式构建的，不过它指定自身的上下文为一个特殊的上下文(EmptyCoroutineContext),这种方式启动的协程不会阻塞父协程。</p>\n<p>​        <code>runBlocking &#123;&#125;</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;GlobalScope::代码块开始::<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    GlobalScope.launch(EmptyCoroutineContext) &#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;GlobalScope::<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;runBlocking::开始阻塞线程&quot;</span>)</span><br><span class=\"line\">    runBlocking(Dispatchers.IO) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;runBlocking::执行结束&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;父协程开始执行&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">22</span>:<span class=\"number\">58</span>:<span class=\"number\">28.810</span> <span class=\"number\">2131</span>-<span class=\"number\">2208</span>/? D/taosi: GlobalScope::代码块开始::DefaultDispatcher-worker-<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">22</span>:<span class=\"number\">58</span>:<span class=\"number\">28.811</span> <span class=\"number\">2131</span>-<span class=\"number\">2208</span>/? D/taosi: runBlocking::开始阻塞线程</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">22</span>:<span class=\"number\">58</span>:<span class=\"number\">28.811</span> <span class=\"number\">2131</span>-<span class=\"number\">2252</span>/? D/taosi: GlobalScope::DefaultDispatcher-worker-<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">22</span>:<span class=\"number\">58</span>:<span class=\"number\">29.817</span> <span class=\"number\">2131</span>-<span class=\"number\">2252</span>/com.example.coroutinedemo D/taosi: runBlocking::执行结束</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">22</span>:<span class=\"number\">58</span>:<span class=\"number\">29.817</span> <span class=\"number\">2131</span>-<span class=\"number\">2208</span>/com.example.coroutinedemo D/taosi: 父协程开始执行</span><br></pre></td></tr></table></figure>\n\n<p><code>runBlocking &#123;&#125;</code>是创建一个新的协程同时阻塞当前线程，直到协程结束。这个不应该在协程中使用，主要是为<code>main</code>函数和测试设计的。</p>\n<p>​    这两种协程的构建方式，一般都是用来从无到有的构建，也就是说在不在协程作用域的情况下我们才会调用这两种方式进行协程的构建。</p>\n<h4 id=\"四、协程的作用域\"><a href=\"#四、协程的作用域\" class=\"headerlink\" title=\"四、协程的作用域\"></a>四、协程的作用域</h4><p><code>CoroutineScope和coroutineScope</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(Dispatchers.IO).launch(CoroutineExceptionHandler &#123; _, e -&gt;</span><br><span class=\"line\">          Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;<span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">      &#125;) &#123;</span><br><span class=\"line\">          Log.d(<span class=\"string\">&quot;taosi&quot;</span>, Thread.currentThread().name)</span><br><span class=\"line\">          launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">              coroutineScope &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">val</span> list = emptyList&lt;<span class=\"built_in\">Long</span>&gt;()</span><br><span class=\"line\">                  list[<span class=\"number\">0</span>]</span><br><span class=\"line\">                  Log.d(<span class=\"string\">&quot;taosi&quot;</span>, Thread.currentThread().name)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">              coroutineScope &#123;</span><br><span class=\"line\">                  delay(<span class=\"number\">1200</span>)</span><br><span class=\"line\">                  Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;dd&quot;</span>)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">23</span>:<span class=\"number\">47</span>:<span class=\"number\">39.722</span> <span class=\"number\">10218</span>-<span class=\"number\">10261</span>/? D/taosi: DefaultDispatcher-worker-<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">23</span>:<span class=\"number\">47</span>:<span class=\"number\">39.732</span> <span class=\"number\">10218</span>-<span class=\"number\">10262</span>/? D/taosi: java.lang.IndexOutOfBoundsException: Empty list doesn<span class=\"string\">&#x27;t contain element at index 0.</span></span><br></pre></td></tr></table></figure>\n\n<p><code>coroutineScope</code> 启动的协程会继承父协程的作用域和上下文，其内部的取消操作是双向传播的，子协程未捕获的异常也会向上传递给父协程,但如果你在父协程外面使用try()catch{}是无法捕获异常的</p>\n<p><code>supervisorScope和SupervisorJob</code></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(context1).launch(CoroutineExceptionHandler &#123; _, e -&gt;</span><br><span class=\"line\">           Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;<span class=\"subst\">$&#123;e&#125;</span>1&quot;</span>)</span><br><span class=\"line\">       &#125;) &#123;</span><br><span class=\"line\">           supervisorScope() &#123;</span><br><span class=\"line\">               launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">val</span> list = emptyList&lt;<span class=\"built_in\">Long</span>&gt;()</span><br><span class=\"line\">                   list[<span class=\"number\">0</span>]</span><br><span class=\"line\">                   Log.d(<span class=\"string\">&quot;taosi&quot;</span>, Thread.currentThread().name)</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           coroutineScope &#123;</span><br><span class=\"line\">               delay(<span class=\"number\">1200</span>)</span><br><span class=\"line\">               Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;dd&quot;</span>)</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">23</span>:<span class=\"number\">45</span>:<span class=\"number\">45.529</span> <span class=\"number\">9543</span>-<span class=\"number\">9599</span>/com.example.coroutinedemo D/taosi: custom_Thread1</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">22</span>:<span class=\"number\">45</span>:<span class=\"number\">45.553</span> <span class=\"number\">9543</span>-<span class=\"number\">9600</span>/com.example.coroutinedemo D/taosi: java.lang.IndexOutOfBoundsException: Empty list doesn<span class=\"string\">&#x27;t contain element at index 0.1</span></span><br><span class=\"line\"><span class=\"string\">2020-06-14 23:45:46.756 9543-9599/com.example.coroutinedemo D/taosi: dd</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br></pre></td></tr></table></figure>\n\n<p><code>supervisorScope</code> 启动的协程也会继承父协程的上下文，但不会继承作用域，它只会单向的传播并且当作业自身执行失败的时候将所有子作业全部取消。作业自身也会在所有的子作业执行结束前等待</p>\n<p>​    一定要区分作用域和协程上下文的区别，协程上下文只是决定当前代码块执行的线程，而作用域是用来决父协程与子携程的异常处理相互关系</p>\n<h4 id=\"五、在父协程中创建子协程\"><a href=\"#五、在父协程中创建子协程\" class=\"headerlink\" title=\"五、在父协程中创建子协程\"></a>五、在父协程中创建子协程</h4><p>​    <code>lauch():Job</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(EmptyCoroutineContext).launch &#123;</span><br><span class=\"line\">    Log.d(&quot;taosi&quot;, Thread.currentThread().name)</span><br><span class=\"line\">    launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">        delay(300)</span><br><span class=\"line\">        Log.d(&quot;taosi&quot;, Thread.currentThread().name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delay(10000)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        直接在父协程中创建一个子协程，运行的线程根据上下文决定。该方法返回一个Job对象，可以对该对象进行控制决定协程什么时候开始执行，什么时候结束，并不会自动挂起父协程。</p>\n<p>​    <code>withContext():T</code></p>\n<p>​        该函数返回一个泛型，这个泛型是由代码块中的返回的类型决定的，适合用于有返回值得异步调用，但又不需要控制子协程的启动与取消。不过需要注意的是，如果使用它开启一个子线程，它会自动挂起父协程。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">           Log.d(<span class=\"string\">&quot;taosi&quot;</span>, Thread.currentThread().id.toString())</span><br><span class=\"line\">           <span class=\"keyword\">val</span> withContextValue = withContext(Dispatchers.Default) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">var</span> test = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">                   delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">                   Log.d(<span class=\"string\">&quot;taosi&quot;</span>, Thread.currentThread().id.toString())</span><br><span class=\"line\">                   test = <span class=\"string\">&quot;withContext&quot;</span></span><br><span class=\"line\">               <span class=\"keyword\">return</span><span class=\"symbol\">@withContext</span> <span class=\"string\">&quot;withCOntext&quot;</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           Log.d(<span class=\"string\">&quot;taosi&quot;</span>, withContextValue)</span><br><span class=\"line\">           Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;test&quot;</span>)</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">23</span>:<span class=\"number\">57</span>:<span class=\"number\">27.556</span> <span class=\"number\">23244</span>-<span class=\"number\">23287</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">35799</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">23</span>:<span class=\"number\">57</span>:<span class=\"number\">28.597</span> <span class=\"number\">23244</span>-<span class=\"number\">23287</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">35799</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">23</span>:<span class=\"number\">57</span>:<span class=\"number\">28.598</span> <span class=\"number\">23244</span>-<span class=\"number\">23287</span>/com.example.coroutinedemo D/taosi: withCOntext</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">13</span> <span class=\"number\">23</span>:<span class=\"number\">57</span>:<span class=\"number\">28.599</span> <span class=\"number\">23244</span>-<span class=\"number\">23287</span>/com.example.coroutinedemo D/taosi: test</span><br></pre></td></tr></table></figure>\n\n<p>​    需要注意的是，由于Dispatchers.IO与Default共用的一个线程池，所以当父协程使用的上下文是Dispatchers.Io或default时，withContext产生的子协程并不会造成实际意义上的切换。若想真正意义上的再次切换一次线程可以像如下一样调用。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Log.d(<span class=\"string\">&quot;taosi&quot;</span>, Thread.currentThread().id.toString())</span><br><span class=\"line\">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">       <span class=\"keyword\">val</span> withContextValue = withContext(Dispatchers.Default) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">var</span> test = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">             <span class=\"keyword\">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">                 delay(<span class=\"number\">3000</span>)</span><br><span class=\"line\">                 Log.d(<span class=\"string\">&quot;taosi&quot;</span>, Thread.currentThread().id.toString())</span><br><span class=\"line\">                 test = <span class=\"string\">&quot;withContext&quot;</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             job.join()</span><br><span class=\"line\">             <span class=\"keyword\">return</span><span class=\"symbol\">@withContext</span> test</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         Log.d(<span class=\"string\">&quot;taosi&quot;</span>, withContextValue)</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">01</span>:<span class=\"number\">02</span>:<span class=\"number\">37.399</span> <span class=\"number\">23580</span>-<span class=\"number\">23631</span>/? D/taosi: <span class=\"number\">35810</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">01</span>:<span class=\"number\">02</span>:<span class=\"number\">38.439</span> <span class=\"number\">23580</span>-<span class=\"number\">23632</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">35811</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">01</span>:<span class=\"number\">02</span>:<span class=\"number\">38.441</span> <span class=\"number\">23580</span>-<span class=\"number\">23632</span>/com.example.coroutinedemo D/taosi: withCOntext</span><br></pre></td></tr></table></figure>\n\n<p>​    <code>async&#123;&#125;:Deffered&lt;T&gt;</code></p>\n<p>​        这个函数通常用于并发请求的操作，<code>Deffered</code>接口继承自Job接口，它提供一个await()函数用于获取异步返回的值，需要注意的是await()是一个挂起函数，当你调用await()时，它会主动的将父协程挂起，等待子协程的返回值，所以如果你想真正意义上的实现两个协程并行工作，应该像如下调用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;<span class=\"subst\">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deffer1 = async(start = CoroutineStart.LAZY) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">500</span>)</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;<span class=\"subst\">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;deffer1&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> deffer2 = async(start = CoroutineStart.LAZY) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">500</span>)</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;<span class=\"subst\">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"string\">&quot;deffer2&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    deffer1.start()</span><br><span class=\"line\">    deffer2.start()</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;<span class=\"subst\">$&#123;deffer1.await()&#125;</span>,<span class=\"subst\">$&#123;deffer2.await()&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">12</span>:<span class=\"number\">40</span>:<span class=\"number\">21.773</span> <span class=\"number\">23984</span>-<span class=\"number\">24042</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">37013</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">12</span>:<span class=\"number\">40</span>:<span class=\"number\">22.281</span> <span class=\"number\">23984</span>-<span class=\"number\">24047</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">37018</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">12</span>:<span class=\"number\">40</span>:<span class=\"number\">22.281</span> <span class=\"number\">23984</span>-<span class=\"number\">24044</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">37015</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">12</span>:<span class=\"number\">40</span>:<span class=\"number\">22.282</span> <span class=\"number\">23984</span>-<span class=\"number\">24047</span>/com.example.coroutinedemo D/taosi: deffer1,deffer12</span><br></pre></td></tr></table></figure>\n\n<p>但还有注意的一点，async是一定会开启一个新线程哪怕是使用<code>EmptyCoroutineContext</code>它依然会重新建立一个新的上下文而不会继承父协程的上下文。</p>\n<h4 id=\"六、取消协程\"><a href=\"#六、取消协程\" class=\"headerlink\" title=\"六、取消协程\"></a>六、取消协程</h4><p>​    先看看以下代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;cancel&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">    job.cancel()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">16</span> <span class=\"number\">23</span>:<span class=\"number\">18</span>:<span class=\"number\">04.673</span> <span class=\"number\">19452</span>-<span class=\"number\">19537</span>/com.example.coroutinedemo D/taosi: cancel</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">16</span> <span class=\"number\">23</span>:<span class=\"number\">18</span>:<span class=\"number\">04.675</span> <span class=\"number\">19452</span>-<span class=\"number\">19537</span>/com.example.coroutinedemo D/taosi: cancel</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">16</span> <span class=\"number\">23</span>:<span class=\"number\">18</span>:<span class=\"number\">04.706</span> <span class=\"number\">19452</span>-<span class=\"number\">19537</span>/com.example.coroutinedemo D/taosi: cancel</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们启动了一个子协程，然后又在100ms后取消了这个子协程，但这个子协程的代码块并没有停止执行，具体原因，可以先看下面代码再做分析：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Log.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;cancelCoroutine::1&quot;</span>)</span><br><span class=\"line\">CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> job = launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    delay(<span class=\"number\">10</span>)</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span> (e:Exception)&#123;</span><br><span class=\"line\">               \t\tLog.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;error:<span class=\"variable\">$e</span>&quot;</span>)</span><br><span class=\"line\">            \t&#125;</span><br><span class=\"line\">            Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;cancel:2&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">    job.cancel()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>-<span class=\"number\">06</span>-<span class=\"number\">16</span> <span class=\"number\">23</span>:<span class=\"number\">44</span>:<span class=\"number\">05.402</span> <span class=\"number\">24104</span>-<span class=\"number\">24168</span>/com.example.coroutinedemo D/taosi: cancel:<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">16</span> <span class=\"number\">23</span>:<span class=\"number\">44</span>:<span class=\"number\">05.402</span> <span class=\"number\">24104</span>-<span class=\"number\">24168</span>/com.example.coroutinedemo D/taosi: error:kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@<span class=\"number\">1</span>d02564</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">16</span> <span class=\"number\">23</span>:<span class=\"number\">44</span>:<span class=\"number\">05.402</span> <span class=\"number\">24104</span>-<span class=\"number\">24168</span>/com.example.coroutinedemo D/taosi: cancel:<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">16</span> <span class=\"number\">23</span>:<span class=\"number\">44</span>:<span class=\"number\">05.402</span> <span class=\"number\">24104</span>-<span class=\"number\">24168</span>/com.example.coroutinedemo D/taosi: error:kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@<span class=\"number\">1</span>d02564</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>这个段代码基本与上面一致唯一的区别是在循环体中我调用了一个系统提供的<code>suspend</code>函数并且用用try{}catch将其捕获，观看结果可以看到我捕获了一个异常,由于将异常捕获协程体依然会运行下去。当把捕获异常的代码删掉时，协程体就会停止执行。也就是说协程的停止实际上是通过抛出特别的异常（<code> JobCancellationException</code>）来进行的，也就是说如果协程体的代码不依赖协程的cancel状态（即没有报错），则协程的取消 对协程体的执行一般没什么影响。</p>\n<h4 id=\"七、挂起与阻塞的区别\"><a href=\"#七、挂起与阻塞的区别\" class=\"headerlink\" title=\"七、挂起与阻塞的区别\"></a>七、挂起与阻塞的区别</h4><p>​    先看看以下代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> context1 = newSingleThreadContext(<span class=\"string\">&quot;custom_Thread1&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">    confirmBlockAndSuspend()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">confirmBlockAndSuspend</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        CoroutineScope(Dispatchers.Main).launch &#123;</span><br><span class=\"line\">            Log.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;main::执行协程1&quot;</span>)</span><br><span class=\"line\">            test1()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        CoroutineScope(Dispatchers.Main).launch &#123;</span><br><span class=\"line\">            Log.d(<span class=\"string\">&quot;taosi&quot;</span>,<span class=\"string\">&quot;main::执行协程2&quot;</span>)</span><br><span class=\"line\">            test2()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        withContext(context1) &#123;</span><br><span class=\"line\">            sleep(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;1::<span class=\"subst\">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        withContext(context1) &#123;</span><br><span class=\"line\">            sleep(<span class=\"number\">200</span>)</span><br><span class=\"line\">            Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;2::<span class=\"subst\">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code> confirmBlockAndSuspend()</code>函数中，我们开启了两个协程，一个协程执行<code>test1()</code>,另一个协程执行<code>test2()</code>,<code>test1()</code>和<code>test2()</code>执行在同一个上下文环境中，即执行在同一个线程中。<code>test1()</code>中我们阻塞线程1000ms然后打印,<code>test2()</code>我们阻塞线程200ms然后打印。让我们来看一下结果：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">12</span>:<span class=\"number\">58</span>:<span class=\"number\">08.672</span> <span class=\"number\">25786</span>-<span class=\"number\">25786</span>/? D/taosi: main::执行协程<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">12</span>:<span class=\"number\">58</span>:<span class=\"number\">08.674</span> <span class=\"number\">25786</span>-<span class=\"number\">25786</span>/? D/taosi: main::执行协程<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">12</span>:<span class=\"number\">58</span>:<span class=\"number\">09.675</span> <span class=\"number\">25786</span>-<span class=\"number\">25857</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">1</span>::<span class=\"number\">37028</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">12</span>:<span class=\"number\">58</span>:<span class=\"number\">09.876</span> <span class=\"number\">25786</span>-<span class=\"number\">25857</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">2</span>::<span class=\"number\">37028</span></span><br></pre></td></tr></table></figure>\n\n<p>根据结果我们不难得出一个结论，阻塞一个线程，会让线程陷入等待，哪怕这个线程并没有干任何事情。这样对于资源上来讲是一种极大的浪费。</p>\n<p>现在我们用<code>delay()</code>替换<code>sleep()</code>，看看如果采用挂起的方式，是否会让这个空闲的线程得到利用</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    withContext(context1) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;1::<span class=\"subst\">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    withContext(context1) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">200</span>)</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;taosi&quot;</span>, <span class=\"string\">&quot;2::<span class=\"subst\">$&#123;Thread.currentThread().id&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">13</span>:<span class=\"number\">04</span>:<span class=\"number\">39.210</span> <span class=\"number\">26277</span>-<span class=\"number\">26277</span>/? D/taosi: main::执行协程<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">13</span>:<span class=\"number\">04</span>:<span class=\"number\">39.213</span> <span class=\"number\">26277</span>-<span class=\"number\">26277</span>/? D/taosi: main::执行协程<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">13</span>:<span class=\"number\">04</span>:<span class=\"number\">39.417</span> <span class=\"number\">26277</span>-<span class=\"number\">26351</span>/? D/taosi: <span class=\"number\">2</span>::<span class=\"number\">37043</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">14</span> <span class=\"number\">13</span>:<span class=\"number\">04</span>:<span class=\"number\">40.215</span> <span class=\"number\">26277</span>-<span class=\"number\">26351</span>/com.example.coroutinedemo D/taosi: <span class=\"number\">1</span>::<span class=\"number\">37043</span></span><br></pre></td></tr></table></figure>\n\n<p>从结果上看，2执行在1前面，挂起并不会阻塞当前的线程，而更像是把挂起之后的代码从当前线程中抽离出来，等待挂起函数执行完毕之后，再将代码post回之前的线程。</p>\n<p>从表面上看协程的挂起机制并不会给我们带来上面性能上的提升，因为一般情况下我们都是在一个协程中将我们想要的事情办完。然而从另一个层面上看，协程确实会提升线程调度的性能，考虑这样一种情况，我们短时间内开了大量协程来帮助我们完成一些任务，这些任务的完成都是需要等待却又不需要消耗cpu的计算资源的，假设我们将所有这些启动的协程的上下文都指定为<code>Dispatchers.IO</code>,这时挂起的优势就体现出来了，当我们开启第一个协程执行任务时，它开始将自己挂起，然后释放掉对线程的控制权，那么后来开启的线程就能使用之前的已经在线程池的线程而不需要自己再重新的去创建一个线程。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2020/09/04/hello-world/",
            "url": "http://example.com/2020/09/04/hello-world/",
            "title": "Hello World",
            "date_published": "2020-09-03T16:10:50.955Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        }
    ]
}